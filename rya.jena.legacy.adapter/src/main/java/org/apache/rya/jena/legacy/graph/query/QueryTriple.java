/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.rya.jena.legacy.graph.query;

import java.util.HashSet;
import java.util.Iterator;

import org.apache.jena.graph.Graph;
import org.apache.jena.graph.Node;
import org.apache.jena.graph.Triple;
import org.apache.jena.shared.BrokenException;

/**
 * A QueryTriple is a composite of three QueryNodes derived from a
 * single source triple. QueryTriple knows how to classify a triple
 * into a QueryTriple based on the classification of that triple's elements.
 * A QueryTriple can create a specific {@code Matcher} which
 * will do the minimal amount of work to match triples that have been
 * generated by {@code find} on the finder of that QueryTriple.
 */
public class QueryTriple {
    public final QueryNode s;
    public final QueryNode p;
    public final QueryNode o;

    /**
     * Creates a new instance of {@link QueryTriple}.
     * @param s the subject {@link QueryNode}.
     * @param p the predicate {@link QueryNode}.
     * @param o the object {@link QueryNode}.
     */
    public QueryTriple(final QueryNode s, final QueryNode p, final QueryNode o) {
        this.s = s;
        this.p = p;
        this.o = o;
    }

    @Override
    public String toString() {
        return "<qt " + s.toString() + " " + p.toString() + " " + o.toString() + ">";
    }

    public static QueryTriple[] classify(final QueryNodeFactory f, final Mapping m, final Triple[] t) {
        final QueryTriple[] result = f.createArray(t.length);
        for (int i = 0; i < t.length; i += 1) {
            result[i] = classify(f, m, t[i]);
        }
        return result;
    }

    public static QueryTriple classify(final QueryNodeFactory f, final Mapping m, final Triple t) {
        final HashSet<Node> fresh = new HashSet<Node>();
        return f.createTriple(QueryNode.classify(f, m, fresh, t.getSubject()), QueryNode.classify(f, m, fresh, t.getPredicate()), QueryNode.classify(f, m, fresh, t.getObject()));
    }

    public Applyer createApplyer(final Graph g) {
        return new SimpleApplyer(g, this);
    }

    public Matcher createMatcher() {
        final int SMATCH = 4, PMATCH = 2, OMATCH = 1, NOMATCH = 0;
        final int bits = (s.mustMatch() ? SMATCH : 0) + (p.mustMatch() ? PMATCH : 0) + (o.mustMatch() ? OMATCH : 0);
        switch (bits) {
        case SMATCH + PMATCH + OMATCH:
            return new Matcher() {
                @Override
                public boolean match(final Domain d, final Triple t) {
                    return s.match(d, t.getSubject()) && p.match(d, t.getPredicate()) && o.match(d, t.getObject());
                }
            };

        case SMATCH + OMATCH:
            return new Matcher() {
                @Override
                public boolean match(final Domain d, final Triple t) {
                    return s.match(d, t.getSubject()) && o.match(d, t.getObject());
                }
            };

        case SMATCH + PMATCH:
            return new Matcher() {
                @Override
                public boolean match(final Domain d, final Triple t) {
                    return s.match(d, t.getSubject()) && p.match(d, t.getPredicate());
                }
            };

        case PMATCH + OMATCH:
            return new Matcher() {
                @Override
                public boolean match(final Domain d, final Triple t) {
                    return p.match(d, t.getPredicate()) && o.match(d, t.getObject());
                }
            };

        case SMATCH:
            return new Matcher() {
                @Override
                public boolean match(final Domain d, final Triple t) {
                    return s.match(d, t.getSubject());
                }
            };

        case PMATCH:
            return new Matcher() {
                @Override
                public boolean match(final Domain d, final Triple t) {
                    return p.match(d, t.getPredicate());
                }
            };

        case OMATCH:
            return new Matcher() {
                @Override
                public boolean match(final Domain d, final Triple t) {
                    return o.match(d, t.getObject());
                }
            };

        case NOMATCH:
            return Matcher.ALWAYS;

        }
        throw new BrokenException("uncatered-for case in optimisation");
    }

    public static class SimpleApplyer extends Applyer {
        protected final Graph g;
        protected final QueryNode s;
        protected final QueryNode p;
        protected final QueryNode o;

        /**
         * Creates a new instance of {@link SimpleApplyer}.
         * @param g the {@link Graph}.
         * @param qt the {@link QueryTriple}.
         */
        protected SimpleApplyer(final Graph g, final QueryTriple qt) {
            this.g = g;
            this.o = qt.o;
            this.p = qt.p;
            this.s = qt.s;
        }

        /**
         * Fins the graph triples in the domain.
         * @param domain the {@link Domain}.
         * @return the {@link Iterator} over the {@link Triple}s.
         */
        public Iterator<Triple> find(final Domain d) {
            return g.find(s.finder(d), p.finder(d), o.finder(d));
        }

        @Override
        public void applyToTriples(final Domain domain, final Matcher matcher, final StageElement next) {
            final Iterator<Triple> it = find(domain);
            while (it.hasNext()) {
                if (matcher.match(domain, it.next())) {
                    next.run(domain);
                }
            }
        }
    }
}